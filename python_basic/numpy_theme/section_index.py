#切片和索引是python序列的共有功能,对于多维的情形的切片，","是分割各个维。索引使用数组来完成，只有一个元素时就写数字本身
#索引复制了一份新的，与原数组互相独立
#需要明确的是无论是索引还是切片，其本身都是指向原数据的，直接改变则会改变原有的。只是索引返回的是复制，切片返回的是同指向的对象
import numpy as np
a = np.array([[1,2,3],[4,5,6],[7,8,9]])
b = a[1:]#切片
b[0][0] = 100
print(a,b)#b改变，a也改变了
c = a[[0,1,2]]#索引
c[0][0] = 888
print(a,c)#索引复制了一份新的数组


#使用python内置函数实现
s = slice(2,7,2)#从第3个到第8个，隔两个取一次
a = np.array([2,3,5,11,12,33,45,51,90,87,73])
print(a[s])

#使用numpy实现
print(a[2:7:2])
"""
冒号 : 的解释：如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 [2:7]，那么则提取两个索引(不包括停止索引)之间的项

"""

#切片还可以包括省略号 …，如果在行位置使用省略号，它将返回包含行中元素的 ndarray

a = np.array([[1,2,3],[3,4,5],[4,5,6]])
print (a[...,1])   # 第2列元素
print (a[1,...])   # 第2行元素
print (a[...,1:])  # 第2列及剩下的所有元素

#高级索引方法

x = np.array([[1,  2],  [3,  4],  [5,  6]])
y = x[[0,1,2],  [0,1,0]]
print (y)#[1 4 5]，即(0,0)，(1,1)和(2,0)位置处的元素


x = np.array([[  0,  1,  2],[  3,  4,  5],[  6,  7,  8],[  9,  10,  11]])
print(x[[0,2,3]])
"""
[[ 0  1  2]
 [ 6  7  8]
 [ 9 10 11]]
"""
rows = np.array([[0,0],[3,3]])
cols = np.array([[0,2],[0,2]])
#所以(0,0) (0,2)为一组；(3,0) (3,2)为一组
y = x[rows,cols]
print  ('这个数组的四个角元素是:')
print (y)

a = np.array([[1,2,3], [4,5,6],[7,8,9]])
b = a[1:3, 1:3]
c = a[1:3,[1,2]]
d = a[...,1:]
print(b)
print(c)
print(d)

#布尔索引

x = np.array([[  0,  1,  2],[  3,  4,  5],[  6,  7,  8],[  9,  10,  11]])
print(x[x > 5])

#过滤
a = np.array([np.nan,  1,2,np.nan,3,4,5])
print (a[~np.isnan(a)])

a = np.array([1,  2+6j,  5,  3.5+5j])
print (a[np.iscomplex(a)])

#花式索引
#索引跟切片不一样，它总是将数据复制到新数组中
a = np.array([1,2,3,4,5])
b = a[2:]
b[1] = 100
print(a,b)#可见切片虽然返回了了新对象，但是他们指向同一个内存
c = a[[1,2,3]]
c[1] = 888
print(a,c)#而索引则开辟了一个新的内存来放索引的内容，所以互不影响

x=np.arange(32).reshape((8,4))
print (x[np.ix_([1,5,7,2],[0,3,1,2])])#选定行、然后再选定列