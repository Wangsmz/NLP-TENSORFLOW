"""字符串匹配,规定主串为s，模式串为p，函数返回的是第一次成功找到模式串时主串开始的位置，比如
s="12345" p="234"返回1，其中位置从0开始计。
"""

"""
1.简单方法也就是直观的方法,也叫brute-force即穷举，最坏的时间复杂度就是内层循环每次都能匹配到最后一个字符，这种情况很容易想象，
此时时间复杂度就是(n-m+1)*m
"""
def bf(s,p):
    #记录比较的次数
    k = 0
    for i in range(0,len(s) - len(p)):
        for j in range(0,len(p)):
            if p[j] == s[i+j]:
                k += 1
                if j == len(p) - 1:
                    print("起始位置是:%d 比较了%d次(来自BF算法)"%(i,k))
                    return
                else:
                    continue
            else:
                k += 1
                break
    print("匹配失败")
s = "12345678"
p = "456"
bf("12345678","456")
"""
2.BM算法(两位发明者名称首字母缩写)。该算法比BF、KMP算法更高效。基本思想是如果某次匹配不成功，那么模式串尽量后移，这样减少了总的匹配次数。具体方法是从后往前匹配，遇到不匹配的那个位置则作如下思考：模式串该位置左侧中如果存在主串中的这个字符，那么直接将模式串第一次出现该字符的位置与该字符对齐，这是因为这两个相同字符之间的位置是没必要匹配的，因为一定不会匹配成功，
这叫做坏字符原则；同理在出现坏字符之前，匹配成功的部分，叫做好后缀，这后缀中的每一个字符跟坏字符一样需要了解模式串的左侧，
距离多远处有与其相同的字符，在这个距离之内是无法匹配成功的；所以最终模式串后移的距离取坏字符与好后缀所得到的最大距离。
BM算法预处理时间复杂度为O（m+s），空间复杂度为O(s)，s是与P, T相关的有限字符集长度，搜索阶段时间复杂度为O(m·n)。
最好情况下的时间复杂度为O(n/m)，最坏情况下时间复杂度为O(m·n)。
"""
"""
KMP算法(三位发明者名称首字母缩写)。方法是某一次匹配遇到不匹配的字符，那么该位置之前的主串中存在一个最大的子串使得模式串
中从第一个开始向右可以找到相同的该子串，那么直接将它们对齐。

"""
